pipeline {
    agent any
    
    environment {
        // AWS Configuration
        AWS_REGION = 'ap-south-1'
        EKS_CLUSTER_NAME = 'my-eks-cluster'
        
        // Application Configuration
        APP_NAME = 'sample-web-app'
        NAMESPACE = 'sample-apps'
        
        // Docker/ECR Configuration
        AWS_ACCOUNT_ID = '897722681721'
        ECR_REGISTRY = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
        IMAGE_REPO = "${ECR_REGISTRY}/${APP_NAME}"
        IMAGE_TAG = "${BUILD_NUMBER}"
        
        // Kubernetes manifests path
        K8S_MANIFESTS_PATH = 'k8s-apps/sample-web-app'
        
        // SNS Notification Configuration
        SNS_TOPIC_ARN = 'arn:aws:sns:ap-south-1:897722681721:jenkins-pipeline-notifications'
        
        // Test Configuration - Choose failure type
        FAILURE_TYPE = "${params.FAILURE_TYPE ?: 'DOCKER_BUILD'}"
    }
    
    parameters {
        choice(
            name: 'FAILURE_TYPE',
            choices: [
                'DOCKER_BUILD',
                'ECR_PUSH',
                'KUBERNETES_DEPLOY',
                'ENVIRONMENT_SETUP',
                'MANIFEST_UPDATE',
                'TIMEOUT_FAILURE',
                'SYNTAX_ERROR'
            ],
            description: 'Select the type of failure to simulate for testing notifications'
        )
        booleanParam(
            name: 'SEND_SUCCESS_NOTIFICATION',
            defaultValue: false,
            description: 'Send notification on success (for testing success notifications)'
        )
    }
    
    stages {
        stage('Test Setup') {
            steps {
                echo 'üß™ Setting up failure test environment...'
                script {
                    echo "üìã Test Configuration:"
                    echo "Failure Type: ${env.FAILURE_TYPE}"
                    echo "SNS Topic: ${env.SNS_TOPIC_ARN}"
                    echo "Send Success Notification: ${params.SEND_SUCCESS_NOTIFICATION}"
                    
                    // Get git commit info for tagging
                    env.GIT_COMMIT_SHORT = sh(
                        script: "git rev-parse --short HEAD",
                        returnStdout: true
                    ).trim()
                    env.IMAGE_TAG = "${BUILD_NUMBER}-${GIT_COMMIT_SHORT}-test"
                }
            }
        }
        
        stage('Environment Setup') {
            steps {
                echo '‚öôÔ∏è Setting up environment...'
                script {
                    if (env.FAILURE_TYPE == 'ENVIRONMENT_SETUP') {
                        echo 'üí• Simulating environment setup failure...'
                        sh '''
                            echo "‚ùå Simulated failure: Unable to configure AWS CLI"
                            echo "This would typically happen when:"
                            echo "- AWS credentials are missing or invalid"
                            echo "- Network connectivity issues"
                            echo "- IAM permissions are insufficient"
                            exit 1
                        '''
                    } else {
                        sh '''
                            echo "Checking tools..."
                            aws --version
                            kubectl version --client
                            docker --version
                            
                            echo "Configuring AWS CLI..."
                            aws configure set region $AWS_REGION
                            aws configure set output json
                            
                            echo "Current AWS Identity:"
                            aws sts get-caller-identity
                        '''
                    }
                }
            }
        }
        
        stage('Syntax Error Test') {
            when {
                environment name: 'FAILURE_TYPE', value: 'SYNTAX_ERROR'
            }
            steps {
                echo 'üí• Simulating syntax error...'
                script {
                    sh '''
                        echo "‚ùå Simulated failure: Script syntax error"
                        echo "This would typically happen when:"
                        echo "- Invalid shell commands"
                        echo "- Missing quotes or brackets"
                        echo "- Undefined variables"
                        # Intentional syntax error
                        invalid_command_that_does_not_exist --with-invalid-flags
                    '''
                }
            }
        }
        
        stage('Docker Build Test') {
            when {
                not { environment name: 'FAILURE_TYPE', value: 'ENVIRONMENT_SETUP' }
                not { environment name: 'FAILURE_TYPE', value: 'SYNTAX_ERROR' }
            }
            steps {
                echo 'üê≥ Testing Docker build...'
                script {
                    if (env.FAILURE_TYPE == 'DOCKER_BUILD') {
                        echo 'üí• Simulating Docker build failure...'
                        sh '''
                            echo "‚ùå Simulated failure: Docker build failed"
                            echo "This would typically happen when:"
                            echo "- Dockerfile syntax errors"
                            echo "- Missing base image"
                            echo "- Network issues downloading dependencies"
                            echo "- Insufficient disk space"
                            echo "- Permission issues with Docker daemon"
                            exit 1
                        '''
                    } else {
                        dir(K8S_MANIFESTS_PATH) {
                            sh '''
                                echo "Building Docker image..."
                                docker build -t $APP_NAME:$IMAGE_TAG .
                                docker tag $APP_NAME:$IMAGE_TAG $IMAGE_REPO:$IMAGE_TAG
                                echo "‚úÖ Docker build successful"
                            '''
                        }
                    }
                }
            }
        }
        
        stage('ECR Push Test') {
            when {
                not { anyOf {
                    environment name: 'FAILURE_TYPE', value: 'ENVIRONMENT_SETUP'
                    environment name: 'FAILURE_TYPE', value: 'SYNTAX_ERROR'
                    environment name: 'FAILURE_TYPE', value: 'DOCKER_BUILD'
                } }
            }
            steps {
                echo '‚¨ÜÔ∏è Testing ECR push...'
                script {
                    if (env.FAILURE_TYPE == 'ECR_PUSH') {
                        echo 'üí• Simulating ECR push failure...'
                        sh '''
                            echo "‚ùå Simulated failure: ECR push failed"
                            echo "This would typically happen when:"
                            echo "- ECR authentication failure"
                            echo "- Repository doesn't exist"
                            echo "- Network connectivity issues"
                            echo "- IAM permissions insufficient"
                            echo "- Registry quota exceeded"
                            exit 1
                        '''
                    } else {
                        sh '''
                            echo "Logging in to ECR..."
                            aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_REGISTRY
                            
                            echo "Pushing Docker image to ECR..."
                            docker push $IMAGE_REPO:$IMAGE_TAG
                            echo "‚úÖ ECR push successful"
                        '''
                    }
                }
            }
        }
        
        stage('Manifest Update Test') {
            when {
                not { anyOf {
                    environment name: 'FAILURE_TYPE', value: 'ENVIRONMENT_SETUP'
                    environment name: 'FAILURE_TYPE', value: 'SYNTAX_ERROR'
                    environment name: 'FAILURE_TYPE', value: 'DOCKER_BUILD'
                    environment name: 'FAILURE_TYPE', value: 'ECR_PUSH'
                } }
            }
            steps {
                echo 'üìù Testing manifest update...'
                script {
                    if (env.FAILURE_TYPE == 'MANIFEST_UPDATE') {
                        echo 'üí• Simulating manifest update failure...'
                        sh '''
                            echo "‚ùå Simulated failure: Manifest update failed"
                            echo "This would typically happen when:"
                            echo "- File permissions issues"
                            echo "- Invalid file paths"
                            echo "- Git repository issues"
                            echo "- Disk space problems"
                            exit 1
                        '''
                    } else {
                        dir(K8S_MANIFESTS_PATH) {
                            sh '''
                                echo "Updating Kubernetes manifests..."
                                sed -i "s|image: .*ecr.*amazonaws.com/sample-web-app:.*|image: $IMAGE_REPO:$IMAGE_TAG|g" deployment-ecr.yaml
                                echo "‚úÖ Manifest update successful"
                            '''
                        }
                    }
                }
            }
        }
        
        stage('Kubernetes Deploy Test') {
            when {
                not { anyOf {
                    environment name: 'FAILURE_TYPE', value: 'ENVIRONMENT_SETUP'
                    environment name: 'FAILURE_TYPE', value: 'SYNTAX_ERROR'
                    environment name: 'FAILURE_TYPE', value: 'DOCKER_BUILD'
                    environment name: 'FAILURE_TYPE', value: 'ECR_PUSH'
                    environment name: 'FAILURE_TYPE', value: 'MANIFEST_UPDATE'
                } }
            }
            steps {
                echo 'üöÄ Testing Kubernetes deployment...'
                script {
                    if (env.FAILURE_TYPE == 'KUBERNETES_DEPLOY') {
                        echo 'üí• Simulating Kubernetes deployment failure...'
                        sh '''
                            echo "‚ùå Simulated failure: Kubernetes deployment failed"
                            echo "This would typically happen when:"
                            echo "- EKS cluster connectivity issues"
                            echo "- kubectl authentication failure"
                            echo "- Invalid Kubernetes manifests"
                            echo "- Resource quota exceeded"
                            echo "- Image pull errors"
                            echo "- Network policies blocking traffic"
                            exit 1
                        '''
                    } else {
                        sh '''
                            echo "Configuring EKS access..."
                            aws eks update-kubeconfig --region $AWS_REGION --name $EKS_CLUSTER_NAME
                            
                            echo "Deploying to Kubernetes..."
                            kubectl get nodes
                            echo "‚úÖ Kubernetes deployment test successful"
                        '''
                    }
                }
            }
        }
        
        stage('Timeout Test') {
            when {
                environment name: 'FAILURE_TYPE', value: 'TIMEOUT_FAILURE'
            }
            timeout(time: 10, unit: 'SECONDS') {
                steps {
                    echo '‚è∞ Testing timeout failure...'
                    script {
                        sh '''
                            echo "üí• Simulating timeout failure..."
                            echo "This test will timeout after 10 seconds"
                            echo "This would typically happen when:"
                            echo "- Deployment rollout takes too long"
                            echo "- Health checks failing"
                            echo "- Network issues causing delays"
                            echo "- Resource constraints"
                            echo "Starting long-running process..."
                            sleep 20  # This will timeout
                        '''
                    }
                }
            }
        }
        
        stage('Success Simulation') {
            when {
                not { anyOf {
                    environment name: 'FAILURE_TYPE', value: 'ENVIRONMENT_SETUP'
                    environment name: 'FAILURE_TYPE', value: 'SYNTAX_ERROR'
                    environment name: 'FAILURE_TYPE', value: 'DOCKER_BUILD'
                    environment name: 'FAILURE_TYPE', value: 'ECR_PUSH'
                    environment name: 'FAILURE_TYPE', value: 'MANIFEST_UPDATE'
                    environment name: 'FAILURE_TYPE', value: 'KUBERNETES_DEPLOY'
                    environment name: 'FAILURE_TYPE', value: 'TIMEOUT_FAILURE'
                } }
            }
            steps {
                echo '‚úÖ All tests passed - simulating successful pipeline'
                script {
                    sh '''
                        echo "üéâ All pipeline stages completed successfully!"
                        echo "This pipeline run will trigger a success notification"
                        echo "if SEND_SUCCESS_NOTIFICATION is enabled"
                    '''
                }
            }
        }
    }
    
    post {
        always {
            echo 'üìä Test pipeline execution completed!'
            script {
                sh '''
                    echo "==================================="
                    echo "Test Pipeline Summary"
                    echo "==================================="
                    echo "Failure Type: $FAILURE_TYPE"
                    echo "Application: $APP_NAME"
                    echo "Build: $BUILD_NUMBER"
                    echo "Git Commit: $GIT_COMMIT_SHORT"
                    echo "==================================="
                '''
            }
        }
        
        success {
            echo '‚úÖ Test pipeline executed successfully!'
            script {
                def shouldSendNotification = params.SEND_SUCCESS_NOTIFICATION
                
                if (shouldSendNotification) {
                    def successMessage = """
‚úÖ JENKINS TEST PIPELINE SUCCEEDED ‚úÖ

üß™ This is a TEST notification from the failure testing pipeline

Job: ${env.JOB_NAME}
Build: #${env.BUILD_NUMBER}
Git Commit: ${env.GIT_COMMIT_SHORT}
Duration: ${currentBuild.durationString}
Failure Type Tested: ${env.FAILURE_TYPE}

Build URL: ${env.BUILD_URL}

üéâ Test completed successfully!
Your SNS email notification system is working correctly.

Time: ${new Date().toString()}

This is a test notification from Jenkins CI/CD Pipeline.
                    """.trim()
                    
                    try {
                        sh """
                            aws sns publish \\
                                --topic-arn ${env.SNS_TOPIC_ARN} \\
                                --subject "‚úÖ TEST: Jenkins Pipeline Success Notification - ${env.JOB_NAME}" \\
                                --message '${successMessage}' \\
                                --region ${env.AWS_REGION}
                        """
                        echo "‚úÖ Test success notification sent via SNS"
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Failed to send test success notification: ${e.getMessage()}"
                    }
                } else {
                    echo "‚ÑπÔ∏è Success notification disabled - set SEND_SUCCESS_NOTIFICATION=true to test"
                }
            }
        }
        
        failure {
            echo '‚ùå Test pipeline failed (as expected)!'
            script {
                sh '''
                    echo "Pipeline failed at stage: $FAILURE_TYPE"
                    echo "This failure was intentional for testing purposes"
                '''
            }
            
            // Send SNS notification on failure
            script {
                def failureMessage = """
üî¥ JENKINS TEST PIPELINE FAILED üî¥

üß™ This is a TEST notification demonstrating failure alerts

Job: ${env.JOB_NAME}
Build: #${env.BUILD_NUMBER}
Git Commit: ${env.GIT_COMMIT_SHORT}
Duration: ${currentBuild.durationString}
Status: ${currentBuild.result}

Failure Type: ${env.FAILURE_TYPE}
Application: ${env.APP_NAME}
Namespace: ${env.NAMESPACE}

Build URL: ${env.BUILD_URL}

üí° Failure Simulation Details:
This failure was intentionally triggered to test the email notification system.

Common causes of '${env.FAILURE_TYPE}' failures:
${getFailureDetails(env.FAILURE_TYPE)}

üîç Troubleshooting Steps:
1. Check the Jenkins build logs at the URL above
2. Verify AWS credentials and permissions
3. Check EKS cluster connectivity
4. Validate Docker and ECR configurations
5. Review Kubernetes manifests for errors

Time: ${new Date().toString()}

This is a test notification from Jenkins CI/CD Pipeline.
                """.trim()
                
                try {
                    sh """
                        aws sns publish \\
                            --topic-arn ${env.SNS_TOPIC_ARN} \\
                            --subject "‚ùå TEST: Jenkins Pipeline Failure Notification - ${env.FAILURE_TYPE}" \\
                            --message '${failureMessage}' \\
                            --region ${env.AWS_REGION}
                    """
                    echo "‚úÖ Test failure notification sent successfully via SNS"
                } catch (Exception e) {
                    echo "‚ö†Ô∏è Failed to send test failure notification: ${e.getMessage()}"
                    echo "Notification content: ${failureMessage}"
                }
            }
        }
        
        aborted {
            echo '‚èπÔ∏è Test pipeline was aborted'
            script {
                def abortMessage = """
‚èπÔ∏è JENKINS TEST PIPELINE ABORTED ‚èπÔ∏è

üß™ This is a TEST notification for pipeline abortion

Job: ${env.JOB_NAME}
Build: #${env.BUILD_NUMBER}
Duration: ${currentBuild.durationString}
Status: ABORTED

Build URL: ${env.BUILD_URL}

The pipeline was manually stopped or timed out during execution.

Time: ${new Date().toString()}
                """.trim()
                
                try {
                    sh """
                        aws sns publish \\
                            --topic-arn ${env.SNS_TOPIC_ARN} \\
                            --subject "‚èπÔ∏è TEST: Jenkins Pipeline Aborted - ${env.JOB_NAME}" \\
                            --message '${abortMessage}' \\
                            --region ${env.AWS_REGION}
                    """
                    echo "‚úÖ Test abort notification sent via SNS"
                } catch (Exception e) {
                    echo "‚ö†Ô∏è Failed to send test abort notification: ${e.getMessage()}"
                }
            }
        }
    }
}

def getFailureDetails(failureType) {
    switch(failureType) {
        case 'DOCKER_BUILD':
            return '''
- Dockerfile syntax errors
- Missing base image or dependencies
- Network issues during image build
- Insufficient disk space
- Docker daemon not running'''
        
        case 'ECR_PUSH':
            return '''
- ECR authentication failure
- Repository doesn't exist
- Network connectivity issues
- IAM permissions insufficient
- Registry quota exceeded'''
        
        case 'KUBERNETES_DEPLOY':
            return '''
- EKS cluster connectivity issues
- kubectl authentication failure
- Invalid Kubernetes manifests
- Resource quota exceeded
- Image pull errors'''
        
        case 'ENVIRONMENT_SETUP':
            return '''
- AWS credentials missing or invalid
- Network connectivity issues
- IAM permissions insufficient
- Tool dependencies not installed'''
        
        case 'MANIFEST_UPDATE':
            return '''
- File permissions issues
- Invalid file paths
- Git repository access problems
- Disk space insufficient'''
        
        case 'TIMEOUT_FAILURE':
            return '''
- Deployment rollout taking too long
- Health checks failing continuously
- Network issues causing delays
- Resource constraints'''
        
        case 'SYNTAX_ERROR':
            return '''
- Invalid shell commands
- Missing quotes or brackets
- Undefined variables
- Script syntax errors'''
        
        default:
            return 'Unknown failure type - check Jenkins logs for details'
    }
}
